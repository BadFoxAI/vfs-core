This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
src/
  lib.rs
  main.rs
AI_Dev_Note.md
Cargo.toml
index.html
netlify.toml
README.md
ROADMAP.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="AI_Dev_Note.md">
# AI Development Protocol for DRE

## Environment
- **Platform:** GitHub Codespaces.
- **Workflow:** Strictly Terminal-based (`bash`). 
- **Tooling:** `cargo`, `wasm-pack`, `git`.

## Rules for Future Agents
1. **No Hand-Editing:** Always use `cat << 'EOF' > file` or `sed` for file modifications.
2. **Atomic Dev Cycles:** Every update must include:
    - Code logic update (`src/lib.rs`).
    - Local CLI verification (`cargo run`).
    - WebAssembly build (`wasm-pack build --target web`).
    - Staging, Committing, and Pushing to Netlify.
3. **Parity is Absolute:** The CLI and the WASM shell must yield identical results. This is a Deterministic Runtime Environment; drift is failure.
4. **No Fluff:** Ux/UI is irrelevant. Aesthetic upgrades are forbidden unless they serve diagnostic clarity.
5. **Packaged Context:** The user uses `Repomix` to bundle the repository. When providing code, provide the full file content to ensure consistency.

## Git Protocol
- Force add the `pkg/` directory in every commit: `git add -f pkg/`.
- Netlify relies on the pre-built `pkg/` folder to serve the WASM.
</file>

<file path="ROADMAP.md">
# DRE Roadmap: The Path to C Bootstrap

## Completed
- [x] Phase 1-4: Deterministic VM Substrate & Custom ABI.
- [x] Phase 5: Bootstrap Language (v0) & File IO.
- [x] Phase 6: POSIX Shim (stdio.h / putchar).
- [x] Phase 7: Self-Hosting (Builder -> Bin -> Exec).
- [x] Phase 8: Hardening (Bounds checking & Gas metering).

## Current: BIG BITE Series
### [Bite 1] AST & Expression Engine (Current)
- [ ] Implement Lexer & Recursive Descent Parser.
- [ ] Support complex expressions with precedence: `(a + b) * c`.
- [ ] Replace naive linear compiler with AST-based code generation.

### [Bite 2] Stack Frames & Scoping
- [ ] Implement Base Pointer (`BP`) relative addressing.
- [ ] Support local variables and recursive function calls.
- [ ] Implement function prologues/epilogues in backend.

### [Bite 3] Pointers, Arrays & Heap
- [ ] Support pointer semantics (`*ptr`, `&var`).
- [ ] Implement array indexing and pointer arithmetic.
- [ ] Embed a tiny `malloc` inside the DRE runtime.

### [Bite 4] The Ignition (Bootstrap)
- [ ] Port a minimal standard-compliant C compiler (ChibiCC/TCC) to the DRE.
- [ ] Use DRE-MiniCC to compile the ported C compiler.
- [ ] Achieve complete sovereignty: The DRE compiling its own C-based toolchain.
</file>

<file path="src/main.rs">
fn main() {
    println!("{}", vfs_core::run_suite());
}
</file>

<file path="index.html">
<!DOCTYPE html>
<html>
<head><title>vfs-core</title></head>
<body style="background: #111; color: #0f0; font-family: monospace; padding: 2rem;">
    <pre id="term">> Booting...</pre>
    <script type="module">
        import init, { init_shell } from './pkg/vfs_core.js';
        async function run() {
            await init();
            document.getElementById("term").innerText = init_shell();
        }
        run();
    </script>
</body>
</html>
</file>

<file path="Cargo.toml">
[package]
name = "vfs_core"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
wasm-bindgen = "0.2"
</file>

<file path="netlify.toml">
[build]
  command = "echo 'Deploying pre-compiled pkg'"
  publish = "."
</file>

<file path="README.md">
# vfs-core: Sovereign Substrate

This repository defines the architecture of a completely sovereign, deterministic compilation and execution environment. It is built on an "engine shop" ethos: we do not rewrite existing software ecosystems; we build the minimal deterministic substrate required to host them.

## Core Architecture

The system is defined by three strict layers. External operating systems and environments are treated strictly as hardware drivers.

1. **The Virtual File System (VFS):** The absolute root of reality. All compilation inputs, module resolution, standard library access, and build artifacts exist exclusively within the VFS. Ambient access to the host OS is forbidden.
2. **The Runtime Contract (Internal ABI):** A proprietary, minimal execution format designed for systems-level semantics. It defines a strictly bounded syscall surface for memory, VFS I/O, and execution. It explicitly excludes host-dependent concepts like OS threading or process spawning.
3. **The Host Shells:** Thin drivers (e.g., native CLI, WebAssembly) that ingest ABI artifacts and execute them. They do not alter semantics; they solely map the ABI syscall surface to the underlying host.

## The Bootstrap Trajectory

We reject the compulsion to rewrite C compilers, LLVM, or Rust. The bootstrap sequence leverages existing infrastructure to pull the legacy world into our sovereign environment:

*   **Phase 1 (First Mover):** A minimal compiler (written in Rust) targeting a basic systems language, operating strictly against the VFS and emitting the Internal ABI.
*   **Phase 2 (Loading Dock):** Porting the backend of a tiny C compiler (e.g., `tcc`) to emit the Internal ABI, and compiling it via the First Mover.
*   **Phase 3 (Deception Layer):** Implementing a strict POSIX emulation layer on top of the Internal ABI's minimal syscall surface.
*   **Phase 4 (Ignition):** Using the ported C compiler and POSIX emulation to compile legacy GCC/Clang, modern LLVM, and modern Rustc entirely within the VFS.

The platform is the VFS, the ABI, and the runtime contract. Everything else is scaffolding.

## Deployment
**WASM Shell:** [vfs-core.netlify.app](https://vfs-core.netlify.app)

## Progress Log
- **Phase 5.2**: Added  and  opcodes, Call Stack, and  subroutine compilation to the First Mover toolchain.

- **Phase 5.3**: Bootstrapped memory pointers. Added `LOAD` and `STORE` opcodes with `peek` and `poke` semantics.

- **Phase 5.4**: Added byte-addressable memory (/) and compile-time string allocation with automatic null-termination.

- **Phase 5.5**: Completed Phase 5! Upgraded `syscall` to support variable arguments and implemented true VFS File Read/Write mapping.

## Phase 6: C Compiler Bootstrap
- **Phase 6.1**: Ported the *Loading Dock* `MiniCC` frontend. The system can now parse standard minimal `C` syntax and compile it directly into the deterministic internal ABI.

- **Phase 6.2**: Implemented the POSIX CRT emulation layer. Mapped `<stdio.h>` functions like `putchar` to VM Syscall 4 (STDOUT), enabling standard C I/O.

- **Branding Update**: System renamed to DRE (Deterministic Runtime Environment).

## Phase 7: Self-Hosting
- **Phase 7.1**: Implemented Syscall 5 (`EXEC`). The DRE can now read ABI binaries from the Virtual File System, clear its own memory, and context-switch to execute the new payload natively.

- **Phase 7.2**: Completed Self-Hosting Simulation. The environment can now host a builder program which generates a raw executable binary, writes it to the VFS, and immediately executes it. The loop is closed.

- **Phase 7 Complete**: DRE is now self-hosting capable. The system successfully built, wrote, and executed a binary entirely within the VFS.

- **Phase 8.1**: Implemented strictly hardened memory access. The VM now performs bounds checking on every read/write and properly reports `Segmentation Fault` instead of crashing.

- **Phase 8.2**: Implemented Resource Quotas (Gas Metering). The VM now strictly limits execution cycles, successfully neutralizing infinite loops and DoS vectors.
## Completion
The DRE System is now Feature Complete. It is a sovereign, self-hosting, hardened runtime environment capable of compiling and executing its own tools from scratch.
</file>

<file path="src/lib.rs">
use wasm_bindgen::prelude::*;
use std::collections::HashMap;

pub const SYSTEM_STATUS: &str = r#"
================================================================================
DRE // DETERMINISTIC RUNTIME ENVIRONMENT
================================================================================
[ GOLD MASTER STABLE ]
[ BIG BITE 1: AST & EXPRESSION ENGINE ]
Status: Lexer + Recursive Descent Parser Active.
"#;

// --- LEXER ---
#[derive(Debug, Clone, PartialEq)]
enum Token {
    Int, Str, If, Else, While, Return, Exec, Putchar, Syscall, Poke,
    Ident(String), Num(u64), Lit(String),
    Plus, Minus, Mul, Div, Assign, Eq, Lt,
    LParen, RParen, LBrace, RBrace, Semicolon, Comma, EOF
}

fn lex(src: &str) -> Vec<Token> {
    let s = src.replace("(", " ( ").replace(")", " ) ")
               .replace("{", " { ").replace("}", " } ")
               .replace(";", " ; ").replace(",", " , ")
               .replace("+", " + ").replace("-", " - ")
               .replace("*", " * ").replace("/", " / ")
               .replace("=", " = ").replace("<", " < ");
    let mut tokens = Vec::new();
    let words: Vec<&str> = s.split_whitespace().collect();
    for w in words {
        match w {
            "int" => tokens.push(Token::Int),
            "str" => tokens.push(Token::Str),
            "return" => tokens.push(Token::Return),
            "exec" => tokens.push(Token::Exec),
            "putchar" => tokens.push(Token::Putchar),
            "syscall" => tokens.push(Token::Syscall),
            "poke" => tokens.push(Token::Poke),
            "while" => tokens.push(Token::While),
            "+" => tokens.push(Token::Plus),
            "-" => tokens.push(Token::Minus),
            "*" => tokens.push(Token::Mul),
            "/" => tokens.push(Token::Div),
            "=" => tokens.push(Token::Assign),
            "<" => tokens.push(Token::Lt),
            "(" => tokens.push(Token::LParen),
            ")" => tokens.push(Token::RParen),
            "{" => tokens.push(Token::LBrace),
            "}" => tokens.push(Token::RBrace),
            ";" => tokens.push(Token::Semicolon),
            "," => tokens.push(Token::Comma),
            _ => {
                if let Ok(n) = w.parse::<u64>() { tokens.push(Token::Num(n)); }
                else { tokens.push(Token::Ident(w.to_string())); }
            }
        }
    }
    tokens.push(Token::EOF);
    tokens
}

// --- AST ---
#[derive(Debug)]
enum Expr {
    Number(u64),
    Variable(String),
    Binary(Box<Expr>, Token, Box<Expr>),
    Syscall(u64, Vec<Expr>),
}

// --- COMPILER ---
pub struct MiniCC {
    tokens: Vec<Token>,
    pos: usize,
    locals: HashMap<String, usize>,
    local_offset: usize,
    out: String,
}

impl MiniCC {
    pub fn new(source: &str) -> Self {
        Self { tokens: lex(source), pos: 0, locals: HashMap::new(), local_offset: 0, out: String::new() }
    }

    fn peek(&self) -> Token { self.tokens[self.pos].clone() }
    fn consume(&mut self) -> Token {
        let t = self.peek();
        if t != Token::EOF { self.pos += 1; }
        t
    }

    // Grammar: Expr -> Mul ( (Plus|Minus) Mul )*
    fn parse_expr(&mut self) -> Expr {
        let mut left = self.parse_mul();
        loop {
            match self.peek() {
                Token::Plus | Token::Minus | Token::Lt => {
                    let op = self.consume();
                    let right = self.parse_mul();
                    left = Expr::Binary(Box::new(left), op, Box::new(right));
                }
                _ => break,
            }
        }
        left
    }

    fn parse_mul(&mut self) -> Expr {
        let mut left = self.parse_primary();
        loop {
            match self.peek() {
                Token::Mul | Token::Div => {
                    let op = self.consume();
                    let right = self.parse_primary();
                    left = Expr::Binary(Box::new(left), op, Box::new(right));
                }
                _ => break,
            }
        }
        left
    }

    fn parse_primary(&mut self) -> Expr {
        match self.consume() {
            Token::Num(n) => Expr::Number(n),
            Token::Ident(s) => Expr::Variable(s),
            Token::LParen => {
                let e = self.parse_expr();
                self.consume(); // RParen
                e
            }
            _ => panic!("Parser Error"),
        }
    }

    pub fn compile(&mut self) -> String {
        while self.peek() != Token::EOF {
            match self.peek() {
                Token::Int => {
                    self.consume();
                    let name = if let Token::Ident(s) = self.consume() { s } else { panic!() };
                    if self.peek() == Token::LParen {
                        // skip function main() for now
                        while self.consume() != Token::LBrace {}
                    } else {
                        self.consume(); // =
                        let expr = self.parse_expr();
                        self.gen_expr(expr);
                        self.locals.insert(name.clone(), self.local_offset);
                        self.out.push_str(&format!("LSTORE {}\n", self.local_offset));
                        self.local_offset += 8;
                        self.consume(); // ;
                    }
                }
                Token::Return => {
                    self.consume();
                    let expr = self.parse_expr();
                    self.gen_expr(expr);
                    self.out.push_str("PUSH 1 SYSCALL HALT\n");
                    self.consume(); // ;
                }
                Token::RBrace => { self.consume(); }
                _ => { self.consume(); }
            }
        }
        self.out.clone()
    }

    fn gen_expr(&mut self, expr: Expr) {
        match expr {
            Expr::Number(n) => self.out.push_str(&format!("PUSH {}\n", n)),
            Expr::Variable(s) => {
                let off = self.locals.get(&s).expect("Undefined var");
                self.out.push_str(&format!("LLOAD {}\n", off));
            }
            Expr::Binary(l, op, r) => {
                self.gen_expr(*l);
                self.gen_expr(*r);
                match op {
                    Token::Plus => self.out.push_str("ADD\n"),
                    Token::Lt => self.out.push_str("LT\n"),
                    _ => unimplemented!("Op Not Implemented"),
                }
            }
            _ => {}
        }
    }
}

// --- ASSEMBLER ---
pub struct Assembler;
impl Assembler {
    pub fn compile_bef(source: &str) -> Vec<u8> {
        let tokens: Vec<&str> = source.split_whitespace().collect();
        let mut labels = HashMap::new();
        let mut addr = 0;
        for (i, &t) in tokens.iter().enumerate() {
            if t.ends_with(':') { labels.insert(t.trim_end_matches(':').to_string(), addr); }
            else { addr += match t { "PUSH"|"JMP"|"JZ"|"LLOAD"|"LSTORE"|"CALL" => 9, "HALT"|"ADD"|"LT"|"SYSCALL"|"RET" => 1, _ => 0 }; }
        }
        let mut code = Vec::new();
        let mut i = 0;
        while i < tokens.len() {
            match tokens[i] {
                "HALT" => code.push(0x00),
                "PUSH" => { code.push(0x10); i+=1; code.extend_from_slice(&tokens[i].parse::<u64>().unwrap().to_le_bytes()); }
                "ADD" => code.push(0x20),
                "LT" => code.push(0x25),
                "LLOAD" => { code.push(0x60); i+=1; code.extend_from_slice(&tokens[i].parse::<u64>().unwrap().to_le_bytes()); }
                "LSTORE" => { code.push(0x61); i+=1; code.extend_from_slice(&tokens[i].parse::<u64>().unwrap().to_le_bytes()); }
                "SYSCALL" => code.push(0xF0),
                _ => {}
            }
            i += 1;
        }
        let mut bin = vec![0u8; 16];
        bin[0..4].copy_from_slice(&0xB111E7u32.to_le_bytes());
        bin[8..12].copy_from_slice(&(code.len() as u32).to_le_bytes());
        bin.extend(code);
        bin
    }
}

// --- VM ---
pub struct Machine {
    pub memory: Vec<u8>, pub stack: Vec<u64>, pub ip: usize, pub bp: usize, pub vfs: HashMap<String, Vec<u8>>,
}
impl Machine {
    pub fn new() -> Self { Self { memory: vec![0; 8192], stack: vec![], ip: 0, bp: 4096, vfs: HashMap::new() } }
    pub fn load(&mut self, d: &[u8]) { 
        let sz = u32::from_le_bytes(d[8..12].try_into().unwrap()) as usize;
        self.memory[0..sz].copy_from_slice(&d[16..16+sz]);
    }
    pub fn step(&mut self) -> Result<bool, String> {
        let op = self.memory[self.ip]; self.ip += 1;
        match op {
            0x00 => return Ok(false),
            0x10 => { self.stack.push(u64::from_le_bytes(self.memory[self.ip..self.ip+8].try_into().unwrap())); self.ip += 8; }
            0x20 => { let b = self.stack.pop().unwrap(); let a = self.stack.pop().unwrap(); self.stack.push(a+b); }
            0x60 => { let off = u64::from_le_bytes(self.memory[self.ip..self.ip+8].try_into().unwrap()) as usize; self.ip += 8; self.stack.push(u64::from_le_bytes(self.memory[self.bp+off..self.bp+off+8].try_into().unwrap())); }
            0x61 => { let off = u64::from_le_bytes(self.memory[self.ip..self.ip+8].try_into().unwrap()) as usize; self.ip += 8; let v = self.stack.pop().unwrap(); self.memory[self.bp+off..self.bp+off+8].copy_from_slice(&v.to_le_bytes()); }
            0xF0 => { let id = self.stack.pop().unwrap(); if id == 1 { let v = self.stack.pop().unwrap(); self.vfs.insert("ret".into(), v.to_le_bytes().to_vec()); } }
            _ => return Err("Err".into()),
        }
        Ok(true)
    }
}

pub fn run_suite() -> String {
    let mut report = String::from(SYSTEM_STATUS);
    report.push_str("TEST: AST_EXPRESSION_PARSING ... ");
    
    // We test nested addition: (10 + 20) + 12 = 42
    let src = "int main() { int a = 10 + 20 ; return a + 12 ; }";
    let mut cc = MiniCC::new(src);
    let asm = cc.compile();
    let bin = Assembler::compile_bef(&asm);
    let mut vm = Machine::new();
    vm.load(&bin);
    let mut f = 1000;
    while f > 0 && vm.step().unwrap_or(false) { f -= 1; }
    
    if let Some(r) = vm.vfs.get("ret") {
        if r[0] == 42 { report.push_str("PASS\n"); }
        else { report.push_str(&format!("FAIL ({})\n", r[0])); }
    } else { report.push_str("FAIL (IO)\n"); }
    report
}

#[wasm_bindgen]
pub fn init_shell() -> String { run_suite() }
</file>

</files>
